Commits

2/24 - Fristian
Initial prototype. Basic movement with a divider in the middle. Enabled the two cameras.

2/27 - Fristian
Removed the divider, and added walls with collisions. Changed FOV on both cameras to 110, character speed for both Black and White to 6, and camera speed to 0.11. Combined the Black and White specific scripts together; we now have a total of 3 scripts at the moment.
I also decided not to add in a time delay after running into walls for two reasons (one it was very complicated, two, it didn't seem too fun after I tried out a semi-working version). If anything, maybe we could add it back in later, but I don't think we need to (I have a feeling the game will be hard enough).
Note: There are a lot of walls at the moment that are just border walls. I'm not sure exactly how we'll handle the wall situation later, but what I have now is just temporary.


3/5 - Fristian
Changed all of the black and white sprites, and the grey sprites to only be white. This is so that we can control exactly how much we want to greyscale anything not exactly white or black by giving it a white sprite and changing the color in the SpriteRenderer's color slider. Something with 128/128/128 is a grey exactly between black and white, something 255/255/255 is fully white, and something 0/0/0 is fully black. In doing this, I also added in the backgrounds. They aren't both exactly white and black to ease the eyes a bit. The black background is currently 13/13/13 while the white background is currently 242/242/242. Walls are 128/128/128 and the divider in the middle as well as the click X's are 84/84/84.
I also added a new Sprite Sorting Layer. So our layers are now Background < Below < Player. The walls and enemies should use the Below layer. The background and players should obviously use the Background and Player layers respectively.
Changed all of the Walls to be instances of a prefab Wall. Will that even make things easier or not? I don't really know, but it's something I figured should be done anyway.
Got rid of that isEnemy boolean in the script MoveTo. This is because I originally used it to not have the X move backwards if an enemy hits a wall (only if you hit a wall, to simulate the player bouncing backwards), but I realized now that the enemies need to move with their own script which will incorporate A*, so I won't be using MoveTo for enemies anyway. I also added a small amount of comments to some of the scripts.
Added one test enemy on the Black Player's side. This enemy uses the MoveTo script for now. We'll replace it with a specific enemy movement script that will have A* pathfinding and will respond to being clicked on eventually. However, since that's basically homework 2, I haven't done that yet.
Note: It seems that sometimes when I save the scene it prints to the console: "Cleaning up leaked objects in scene since no game object, component or manager is referencing them. X has been leaked Y times." I have a feeling this is because of the prefabs, but I don't know exactly.
Note again: I like to name objects in a certain way if you haven't noticed. Since there's usually 2 copies of any object we make due to the nature of the split screen, I'll usually name it WhateverBlack and WhateverWhite (or WhateverB and WhateverW if the name gets really long), so that if we sort by alphabetical, all related objects should be next to each other. In this way, despite the background color, I refer to the left side as "Black" and the right side as "White" because of the Player's color, as in, left is Black's side and right is White's side. If we could keep up this naming scheme in the future, that'd be swell.

3/25 - Fristian
I know Will did a commit on 3/21, but he didn't document much so I'll recap what I know he did.
Will added in an attempt to make a ripple animation, which looked okay. However it caused a few minor problems that we didn't understand fully, so I pulled them for now. He also added a tag for the wall prefab, which could be helpful for future stuff.
He also changed the MoveTo script to factor in the ripples, but since I removed the animation, I commented out the sections that explicitly deal with the ripple animation. I left some other stuff relating to the ripples in (like the tags, prefabs, and scripts), but we can deal with that later.
For what I did myself, I was told by the professor to copy the current scene into 4 new scenes that we'll be working with for our individual stuff. I also added in a folder specifically for prefabs, so that we don't just have them lying about. I also removed square.png since it was redundant (it was literally the same thing as white.png).

3/27 - Fristian
I did a lot, so I hope I don't forget something. Not all of it will affect other scenes, but some of it might.
TLDR: I added a graph, enemies, and made them move around in it.
Unity things:
I made some progress in understanding Unity's Layers and LayerMasks. When using a raycast, you can choose to only raycast colliders on a certain layer, or colliders not on a certain layer. To do this, the object needs to have that layer set in their inspector, and then you need to specify that layer in the code. I used two of the User Layers for Nodes and Enemies. All nodes have the Node layer, and all enemies should have the Enemy layer. This is so that enemies can raycast from themselves and ignore both their own colliders, and the colliders of the nodes. To get the layer for any object except those using the Node Layer (basically, using a ray/line/circle cast on anything but a node) you can use '~LayerMask.GetMask ("Node")' minus the single quotes. This is important, so remember this.
I also made the players tag's match up with PlayerBlack and PlayerWhite.
I added a prefab for one specific type of enemy, a simple square that slowly moves towards a target. We're likely to have more later on.
And I don't know about you guys, but for me, the Wall prefab was a little messed up earlier, like it was showing it had child prefabs, but it didn't, or something? Either way I fixed it up.

Other things:
I created two new scripts, GenerateGraph and EnemeyController.
GenerateGraph creates a graph of nodes. These nodes are gameObjects that only have circleColliders on them. It creates two spaces of nodes where they are generated in a rectangular pattern based off of a set left/top/right/bottom boundary, which is set in the Unity Editor as two float arrays. The nodes that are close to each other are then connected, giving us one big disconnected graph (a graph where not every node is connected to each other).
EnemyController implements the Finite State Machine behavior on the enemy. The state is represented by an enum. The enemy continuously casts a ray towards it's target. If the target's visible, it will seek directly towards it. If not, it'll calculate an A* path towards it, recalculating it if the target moves towards a new node. If clicked on with the correct mouse button, it'll be in paralyzed state. After a few seconds, it will unfreeze and continue to try and move towards the player.

3/27 - Will
Small update to give everyone a cleaner start. Removed Scipt component on Middle camera. Disabled Animation and Animator Controller on Ripple prefabs. Added Animations and Audio folders (empty).
Completed Enemy Spawner, added tag for Enemies.

3/28 - Will
Added a demo scene, changed a few numbers for the EnemySpawner prefab. Demo scene needs testing and feedback before the presentation (it is definately not final at the moment).

3/29 - Fristian
Cleaned up some stuff in GenerateGraph.cs and EnemyController.cs. Enemies should no longer take weird paths to a node before starting their A*, nor should they clip through the walls. The way I did this was that originally, the check to see if an object was visible was a LineCast. This meant that if the line touched the target, even though it was really thin, it would immediately seek towards it's target. I changed this to a CircleCast, which essentially drags a circle shaped raycast across the scene, with the diameter of the circle being a tiny bit bigger than the sprite's width. So now it'll only start moving directly towards the player if there is enough empty space for the enemy's sprite to move through. Note however, that I didn't add any collision detection with walls or anything, so the enemy's still have the potential to run through walls. They just shouldn't. Maybe I'll fix this later. In doing this I also added a little extra check in GenerateGraph that doesn't connect two adjacent nodes if the spacing between them isn't sufficiently large. I might need to tweak this later.
I also made the radius float in GenerateGraph private, and set it to 0.9. Thanks to Will's demo scene I realized that 0.5 wasn't enough to prevent nodes from being created right next to walls, and so since I had that CircleCast check earlier, those nodes that partially spawned within the walls weren't connected to any other nodes, giving errors when trying to A* to/from/through them. However, 1 was too big, and it would prevent nodes from being spawned close to certain walls. So I found 0.9 was good, and I don't want to change it and then have a problem like before.
A few extra things. I made the ClickPosition objects in my scene have the Background sprite layer. This is because in my scene, there is one enemy that follows the mouse position instead of the player, and since enemy's have the Below sprite layer, if it successfully ran into the click position, the sprite for the X would move above the enemy. And it's okay that both BGWhite and BGBlack have the background layer too. The click position still stays on top of them, so I recommend changing the ClickPosition object's sprite layers to Background for all scenes.

3/29 - Will
Added more to the right side of the Demo scene and renamed it. The left side of the demo is meant to show off "combat" and the right side is meant to show off A*/navigation.

3/30 - Fristian
Okay, Big updates on the way.
The first major thing was that I added the ability for sound. In order to have sound play, the Player objects need audio sources attached to them. I went ahead and added audio sources to each scene's PlayerBlack and PlayerWhite. We also need sound clips which attach to the enemy script (so that different enemy types can have different sounds associated with them). I have 3 clips associated with each enemy: the 'freezeSound' when you neutralize an enemy, the 'damageSound' when you get hit, and the 'killSound' when you collide with a neutralized enemy. Each of these is a different drum sound with an ambient reverb effect.
Music can also be played as well with the PlayMusic.cs script. In order for that to work, you'll need to set up two audioSources to whichever gameObject this attaches to (I suggest CameraMiddle for obvious reasons). One source will have the "intro" portion of the song that plays first which will be named whateverIntro. The second source will have the "loop" portion of the song that plays after the intro and keeps looping which will be named whateverLoop. whateverIntro and whateverLoop need to be set in the audioSource's AudioClip section in the inspector. Then you drag both of those audioSources as the public variables in PlayMusic. Ideally, you should set the audioSource with whateverIntro to PlayOnAwake, and the one with whateverLoop to not PlayOnAwake, but I have code that lets the music play correctly anyway in case you're silly and forget. For now I have a few songs that we can test with, and I'll add in more later. I set up music in both my scene, and the demo scene.
Note that all sound files are wavs. Unity has ways to compress audio, so I didn't want to put in compressed files. Plus, looping mp3's adds a small delay to the startup due to the need to uncompress, so we can compress the wavs later (or maybe we can use oggs? Idk).
The second major update is in the enemies. I changed the way the enemy script layout is to how I described it before. All enemy's will have a script called EnemyController, which is the basis for all enemies. This includes variables like moveSpeed, the State me, frozenSeconds, and other things all enemies need. This script now only holds the foundation for the enemies, and does not move them. To make enemies do something, we'll need to create new behavior scripts that are specific to that enemy type, and would be a part of their own prefab. For example, the seeking behavior EnemyController used to do is now in a script called EnemySeeker (if has sight, move towards target. If not, A* towards target). To test this out, I created one new enemy type called EnemyRotater, which rotates in place until it sees the player, where it then rotates faster and starts to slowly move towards the player.
In doing so, I messed around with spawning as well. I made it so that the spawner knows which side it's spawning from due to it's x position (like how Will was saying in class), and spawns from there. Since the script changed a bit, you now have to set the enemy prefab to instantiate (enemyPrefab), the object the enemy's will move to (followThis), the move speed of the objects spawned (myMoveSpeed), and the amount of time spent frozen for each object you spawn (myFrozenSeconds) for each EnemySpanwer you place on the map. In doing so, the spawner will spawn new enemies of that prefab and set their values accordingly. In addition, I sort of set the groundwork to allow us to spawn faster and faster enemies if you stay idle for too long. Of course, that hasn't been put in yet, but when it does it won't be hard to spawn increasingly faster enemies.
Note that for at least now, One spawner won't spawn different types of enemies for the same prefab. For instance, slower squares that unfreeze faster would need their own EnemySpawner. However, I've added a few functions in EnemySpawner that could help us out with that.
The last big thing I did was I changed the way fighting worked. Originally, the enemies made a call to OnMouseOver and if you clicked them while your mouse was over them, they got neutralized. However, if there were multiple colliders in the way, or if enemies stacked on top of each other, or if the camera was moving a lot, it was kind of difficult to click on them properly. I changed this so that instead of the enemies handling neutralization, the ClickToMove script attached to the Player does. When you click the button you don't use to move, it does a GetRayIntersectionAll from the clicking position, which shoots a ray into the scene and returns a list of all colliders it hits. This is done on the Enemy layer so it only hits enemies. It then loops through each enemy hit and calls the Neutralize function on the enemy itself, which tells it to freeze. The benefit of this is that if enemies all clump together, one click will freeze them all, provided that one click hit all of their colliders.
Final note: That thing I said earlier about the clickPosition's sprite layer, well it didn't work all that well. So I changed BGWhite and BGBlack's sprite layer to default, and the click's sprite layer's to Background. Now the click is between the background and the everything else.

3/30 FollowUp - Fristian
So I couldn't resist messing with stuff again. Working on this game is what I like to do when I'm bored or don't want to do my other work, so lucky for us I guess. I made fixes to a few problems Will pointed out to me, and cleaned up some other code that I wrote a while ago.
CenterOn is a lot cleaner now, and travels at the same speed as the player at all stages, meaning we don't have to set our speed to .11 like we did before. This also made it so that there's no more of that tiny shaking the player did sometimes when moving diagonally across the screen.
I added in the check for EnemySpawnerController to see if the spawner is in range of the camera (with some leniency). I also cleaned up some private variables I didn't want showing up in the Inspector (childrenSpawned).
I also made it so that we can easily swap between two methods of attack to test which one is better. Either clicking on an enemy freezes them, and they are unaffected by all clicks until they unfreeze, or clicking on a frozen enemy resets their frozen timer. I'm partial to the first way, but we can play around with both and see which ones we like better.
Unity is also now keeping compressed versions of the song files in memory (doesn't change the fact that they're still .wav's in our folder though).

4/1 Sound - Fristian
So I goofed. I thought that Unity wanted us to import songs as uncompressed wav files and then have Unity itself compressed them. This is true only if you wanted to compress to mp3. If you're on Windows/Mac, it defaults to compressing wavs to ogg files, and you can import ogg files into Unity directly without a loss of sound quality, so this whole time we didn't need those gigantic wav files cluttering our assets folder. I replaced all the music files from .wav's to .ogg's, which had a tremendous affect on size (some files went from like 44MB to 2MB), so hopefully that'll help. The sounds effects were kept as .wav though, since they're small enough.
I also did a few extra misc. things that really aren't that big of a deal to talk about.

4/3 - Fristian
I did something that is very important. I need us to test it out as much as we can.
In ClickToMove, I added in a check that makes it so that right-clicking on the left side of the screen won't move the white player, and left-clicking on the right side won't move the black player. This is on by default, and pressing the 'H' key switches it back to the way we've had it before, where clicking anywhere moves anyone. I really want us all to test levels and just mess around with it, to see which one we like better. It'll be very important as we get close to wrapping up the mechanics and go into nothing but level design / aesthetics. One thing I've realized is that with the new way, it actually forces you to pay more attention, since the characters tend to go idle sooner than they used to. Once we get the idle penalties set in, this could actually be much harder.
I also added one more type of enemy, a sort of missile enemy that bounces around the level. If it sees the player after a bounce, it'll lock it's position and head directly for where the player was. If it doesn't see the player after a bounce, it'll just keep bouncing around. This is based off of what Will explained to me, but if anyone wants to mess with the functionality, feel free.
Another important note: I moved the OnTriggerEnter2D from EnemyController to the separate enemy scripts (like EnemySeeker and EnemyRotater). This is so that we can have separate functionality for each enemy type when they collide with different colliders, like the player, walls, or whatever.

4/3 - Will
Added Sticky enemy type and associated script, added Object Rotator script (may never be used but it's there), gave rigidbodies to Walls instead of enemies.
