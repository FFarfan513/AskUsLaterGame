Commits

2/24 - Fristian
Initial prototype. Basic movement with a divider in the middle. Enabled the two cameras.

2/27 - Fristian
Removed the divider, and added walls with collisions. Changed FOV on both cameras to 110, character speed for both Black and White to 6, and camera speed to 0.11. Combined the Black and White specific scripts together; we now have a total of 3 scripts at the moment.
I also decided not to add in a time delay after running into walls for two reasons (one it was very complicated, two, it didn't seem too fun after I tried out a semi-working version). If anything, maybe we could add it back in later, but I don't think we need to (I have a feeling the game will be hard enough).
Note: There are a lot of walls at the moment that are just border walls. I'm not sure exactly how we'll handle the wall situation later, but what I have now is just temporary.


3/5 - Fristian
Changed all of the black and white sprites, and the grey sprites to only be white. This is so that we can control exactly how much we want to greyscale anything not exactly white or black by giving it a white sprite and changing the color in the SpriteRenderer's color slider. Something with 128/128/128 is a grey exactly between black and white, something 255/255/255 is fully white, and something 0/0/0 is fully black. In doing this, I also added in the backgrounds. They aren't both exactly white and black to ease the eyes a bit. The black background is currently 13/13/13 while the white background is currently 242/242/242. Walls are 128/128/128 and the divider in the middle as well as the click X's are 84/84/84.
I also added a new Sprite Sorting Layer. So our layers are now Background < Below < Player. The walls and enemies should use the Below layer. The background and players should obviously use the Background and Player layers respectively.
Changed all of the Walls to be instances of a prefab Wall. Will that even make things easier or not? I don't really know, but it's something I figured should be done anyway.
Got rid of that isEnemy boolean in the script MoveTo. This is because I originally used it to not have the X move backwards if an enemy hits a wall (only if you hit a wall, to simulate the player bouncing backwards), but I realized now that the enemies need to move with their own script which will incorporate A*, so I won't be using MoveTo for enemies anyway. I also added a small amount of comments to some of the scripts.
Added one test enemy on the Black Player's side. This enemy uses the MoveTo script for now. We'll replace it with a specific enemy movement script that will have A* pathfinding and will respond to being clicked on eventually. However, since that's basically homework 2, I haven't done that yet.
Note: It seems that sometimes when I save the scene it prints to the console: "Cleaning up leaked objects in scene since no game object, component or manager is referencing them. X has been leaked Y times." I have a feeling this is because of the prefabs, but I don't know exactly.
Note again: I like to name objects in a certain way if you haven't noticed. Since there's usually 2 copies of any object we make due to the nature of the split screen, I'll usually name it WhateverBlack and WhateverWhite (or WhateverB and WhateverW if the name gets really long), so that if we sort by alphabetical, all related objects should be next to each other. In this way, despite the background color, I refer to the left side as "Black" and the right side as "White" because of the Player's color, as in, left is Black's side and right is White's side. If we could keep up this naming scheme in the future, that'd be swell.

3/25 - Fristian
I know Will did a commit on 3/21, but he didn't document much so I'll recap what I know he did.
Will added in an attempt to make a ripple animation, which looked okay. However it caused a few minor problems that we didn't understand fully, so I pulled them for now. He also added a tag for the wall prefab, which could be helpful for future stuff.
He also changed the MoveTo script to factor in the ripples, but since I removed the animation, I commented out the sections that explicitly deal with the ripple animation. I left some other stuff relating to the ripples in (like the tags, prefabs, and scripts), but we can deal with that later.
For what I did myself, I was told by the professor to copy the current scene into 4 new scenes that we'll be working with for our individual stuff. I also added in a folder specifically for prefabs, so that we don't just have them lying about. I also removed square.png since it was redundant (it was literally the same thing as white.png).

3/27 - Fristian
I did a lot, so I hope I don't forget something. Not all of it will affect other scenes, but some of it might.
TLDR: I added a graph, enemies, and made them move around in it.
Unity things:
I made some progress in understanding Unity's Layers and LayerMasks. When using a raycast, you can choose to only raycast colliders on a certain layer, or colliders not on a certain layer. To do this, the object needs to have that layer set in their inspector, and then you need to specify that layer in the code. I used two of the User Layers for Nodes and Enemies. All nodes have the Node layer, and all enemies should have the Enemy layer. This is so that enemies can raycast from themselves and ignore both their own colliders, and the colliders of the nodes. To get the layer for any object except those using the Node Layer (basically, using a ray/line/circle cast on anything but a node) you can use '~LayerMask.GetMask ("Node")' minus the single quotes. This is important, so remember this.
I also made the players tag's match up with PlayerBlack and PlayerWhite.
I added a prefab for one specific type of enemy, a simple square that slowly moves towards a target. We're likely to have more later on.
And I don't know about you guys, but for me, the Wall prefab was a little messed up earlier, like it was showing it had child prefabs, but it didn't, or something? Either way I fixed it up.

Other things:
I created two new scripts, GenerateGraph and EnemeyController.
GenerateGraph creates a graph of nodes. These nodes are gameObjects that only have circleColliders on them. It creates two spaces of nodes where they are generated in a rectangular pattern based off of a set left/top/right/bottom boundary, which is set in the Unity Editor as two float arrays. The nodes that are close to each other are then connected, giving us one big disconnected graph (a graph where not every node is connected to each other).
EnemyController implements the Finite State Machine behavior on the enemy. The state is represented by an enum. The enemy continuously casts a ray towards it's target. If the target's visible, it will seek directly towards it. If not, it'll calculate an A* path towards it, recalculating it if the target moves towards a new node. If clicked on with the correct mouse button, it'll be in paralyzed state. After a few seconds, it will unfreeze and continue to try and move towards the player.

3/27 - Will
Small update to give everyone a cleaner start. Removed Scipt component on Middle camera. Disabled Animation and Animator Controller on Ripple prefabs. Added Animations and Audio folders (empty).
Completed Enemy Spawner, added tag for Enemies.

3/28 - Will
Added a demo scene, changed a few numbers for the EnemySpawner prefab. Demo scene needs testing and feedback before the presentation (it is definately not final at the moment).

3/29 - Fristian
Cleaned up some stuff in GenerateGraph.cs and EnemyController.cs. Enemies should no longer take weird paths to a node before starting their A*, nor should they clip through the walls. The way I did this was that originally, the check to see if an object was visible was a LineCast. This meant that if the line touched the target, even though it was really thin, it would immediately seek towards it's target. I changed this to a CircleCast, which essentially drags a circle shaped raycast across the scene, with the diameter of the circle being a tiny bit bigger than the sprite's width. So now it'll only start moving directly towards the player if there is enough empty space for the enemy's sprite to move through. Note however, that I didn't add any collision detection with walls or anything, so the enemy's still have the potential to run through walls. They just shouldn't. Maybe I'll fix this later. In doing this I also added a little extra check in GenerateGraph that doesn't connect two adjacent nodes if the spacing between them isn't sufficiently large. I might need to tweak this later.
I also made the radius float in GenerateGraph private, and set it to 0.9. Thanks to Will's demo scene I realized that 0.5 wasn't enough to prevent nodes from being created right next to walls, and so since I had that CircleCast check earlier, those nodes that partially spawned within the walls weren't connected to any other nodes, giving errors when trying to A* to/from/through them. However, 1 was too big, and it would prevent nodes from being spawned close to certain walls. So I found 0.9 was good, and I don't want to change it and then have a problem like before.
A few extra things. I made the ClickPosition objects in my scene have the Background sprite layer. This is because in my scene, there is one enemy that follows the mouse position instead of the player, and since enemy's have the Below sprite layer, if it successfully ran into the click position, the sprite for the X would move above the enemy. And it's okay that both BGWhite and BGBlack have the background layer too. The click position still stays on top of them, so I recommend changing the ClickPosition object's sprite layers to Background for all scenes.

3/29 - Will
Added more to the right side of the Demo scene and renamed it. The left side of the demo is meant to show off "combat" and the right side is meant to show off A*/navigation.

3/30 - Fristian
Okay, Big updates on the way.
The first major thing was that I added the ability for sound. In order to have sound play, the Player objects need audio sources attached to them. I went ahead and added audio sources to each scene's PlayerBlack and PlayerWhite. We also need sound clips which attach to the enemy script (so that different enemy types can have different sounds associated with them). I have 3 clips associated with each enemy: the 'freezeSound' when you neutralize an enemy, the 'damageSound' when you get hit, and the 'killSound' when you collide with a neutralized enemy. Each of these is a different drum sound with an ambient reverb effect.
Music can also be played as well with the PlayMusic.cs script. In order for that to work, you'll need to set up two audioSources to whichever gameObject this attaches to (I suggest CameraMiddle for obvious reasons). One source will have the "intro" portion of the song that plays first which will be named whateverIntro. The second source will have the "loop" portion of the song that plays after the intro and keeps looping which will be named whateverLoop. whateverIntro and whateverLoop need to be set in the audioSource's AudioClip section in the inspector. Then you drag both of those audioSources as the public variables in PlayMusic. Ideally, you should set the audioSource with whateverIntro to PlayOnAwake, and the one with whateverLoop to not PlayOnAwake, but I have code that lets the music play correctly anyway in case you're silly and forget. For now I have a few songs that we can test with, and I'll add in more later. I set up music in both my scene, and the demo scene.
Note that all sound files are wavs. Unity has ways to compress audio, so I didn't want to put in compressed files. Plus, looping mp3's adds a small delay to the startup due to the need to uncompress, so we can compress the wavs later (or maybe we can use oggs? Idk).
The second major update is in the enemies. I changed the way the enemy script layout is to how I described it before. All enemy's will have a script called EnemyController, which is the basis for all enemies. This includes variables like moveSpeed, the State me, frozenSeconds, and other things all enemies need. This script now only holds the foundation for the enemies, and does not move them. To make enemies do something, we'll need to create new behavior scripts that are specific to that enemy type, and would be a part of their own prefab. For example, the seeking behavior EnemyController used to do is now in a script called EnemySeeker (if has sight, move towards target. If not, A* towards target). To test this out, I created one new enemy type called EnemyRotater, which rotates in place until it sees the player, where it then rotates faster and starts to slowly move towards the player.
In doing so, I messed around with spawning as well. I made it so that the spawner knows which side it's spawning from due to it's x position (like how Will was saying in class), and spawns from there. Since the script changed a bit, you now have to set the enemy prefab to instantiate (enemyPrefab), the object the enemy's will move to (followThis), the move speed of the objects spawned (myMoveSpeed), and the amount of time spent frozen for each object you spawn (myFrozenSeconds) for each EnemySpanwer you place on the map. In doing so, the spawner will spawn new enemies of that prefab and set their values accordingly. In addition, I sort of set the groundwork to allow us to spawn faster and faster enemies if you stay idle for too long. Of course, that hasn't been put in yet, but when it does it won't be hard to spawn increasingly faster enemies.
Note that for at least now, One spawner won't spawn different types of enemies for the same prefab. For instance, slower squares that unfreeze faster would need their own EnemySpawner. However, I've added a few functions in EnemySpawner that could help us out with that.
The last big thing I did was I changed the way fighting worked. Originally, the enemies made a call to OnMouseOver and if you clicked them while your mouse was over them, they got neutralized. However, if there were multiple colliders in the way, or if enemies stacked on top of each other, or if the camera was moving a lot, it was kind of difficult to click on them properly. I changed this so that instead of the enemies handling neutralization, the ClickToMove script attached to the Player does. When you click the button you don't use to move, it does a GetRayIntersectionAll from the clicking position, which shoots a ray into the scene and returns a list of all colliders it hits. This is done on the Enemy layer so it only hits enemies. It then loops through each enemy hit and calls the Neutralize function on the enemy itself, which tells it to freeze. The benefit of this is that if enemies all clump together, one click will freeze them all, provided that one click hit all of their colliders.
Final note: That thing I said earlier about the clickPosition's sprite layer, well it didn't work all that well. So I changed BGWhite and BGBlack's sprite layer to default, and the click's sprite layer's to Background. Now the click is between the background and the everything else.

3/30 FollowUp - Fristian
So I couldn't resist messing with stuff again. Working on this game is what I like to do when I'm bored or don't want to do my other work, so lucky for us I guess. I made fixes to a few problems Will pointed out to me, and cleaned up some other code that I wrote a while ago.
CenterOn is a lot cleaner now, and travels at the same speed as the player at all stages, meaning we don't have to set our speed to .11 like we did before. This also made it so that there's no more of that tiny shaking the player did sometimes when moving diagonally across the screen.
I added in the check for EnemySpawnerController to see if the spawner is in range of the camera (with some leniency). I also cleaned up some private variables I didn't want showing up in the Inspector (childrenSpawned).
I also made it so that we can easily swap between two methods of attack to test which one is better. Either clicking on an enemy freezes them, and they are unaffected by all clicks until they unfreeze, or clicking on a frozen enemy resets their frozen timer. I'm partial to the first way, but we can play around with both and see which ones we like better.
Unity is also now keeping compressed versions of the song files in memory (doesn't change the fact that they're still .wav's in our folder though).

4/1 Sound - Fristian
So I goofed. I thought that Unity wanted us to import songs as uncompressed wav files and then have Unity itself compressed them. This is true only if you wanted to compress to mp3. If you're on Windows/Mac, it defaults to compressing wavs to ogg files, and you can import ogg files into Unity directly without a loss of sound quality, so this whole time we didn't need those gigantic wav files cluttering our assets folder. I replaced all the music files from .wav's to .ogg's, which had a tremendous affect on size (some files went from like 44MB to 2MB), so hopefully that'll help. The sounds effects were kept as .wav though, since they're small enough.
I also did a few extra misc. things that really aren't that big of a deal to talk about.

4/3 - Fristian
I did something that is very important. I need us to test it out as much as we can.
In ClickToMove, I added in a check that makes it so that right-clicking on the left side of the screen won't move the white player, and left-clicking on the right side won't move the black player. This is on by default, and pressing the 'H' key switches it back to the way we've had it before, where clicking anywhere moves anyone. I really want us all to test levels and just mess around with it, to see which one we like better. It'll be very important as we get close to wrapping up the mechanics and go into nothing but level design / aesthetics. One thing I've realized is that with the new way, it actually forces you to pay more attention, since the characters tend to go idle sooner than they used to. Once we get the idle penalties set in, this could actually be much harder.
I also added one more type of enemy, a sort of missile enemy that bounces around the level. If it sees the player after a bounce, it'll lock it's position and head directly for where the player was. If it doesn't see the player after a bounce, it'll just keep bouncing around. This is based off of what Will explained to me, but if anyone wants to mess with the functionality, feel free.
Another important note: I moved the OnTriggerEnter2D from EnemyController to the separate enemy scripts (like EnemySeeker and EnemyRotater). This is so that we can have separate functionality for each enemy type when they collide with different colliders, like the player, walls, or whatever.

4/3 - Will
Added Sticky enemy type and associated script, added Object Rotator script (may never be used but it's there), gave rigidbodies to Walls instead of enemies.
FollowUp = Removed ObjectRotator.cs, added Goal prefab, which knows which side it's on and spins faster when the player is inside it. Also put commented code to add ripple animations inside it if I make those animations again. Goals can be used as switches if its wallToDestroy is not null; the selected wall (from the Scene not Assets!) will be destroyed along with the switch when the player enters it (recommend switches be scaled to 1 to differentiate them from goals).

4/5 - Fristian
Okay, so first off, I did some things and found out some things to make level building a little easier. In doing so I created an easy level-1 sort of level in the scene 'level0'. Most things I'm going to talk about deal with that scene, so you can look at it for reference.
For the Background, it's easiest if instead of making our background as huge as our level, to just make the background follow the player as it moves, and keep it the size of the screen. You can do this by scaling the transform's scale down to 20,20,1, and moving the BGWhite object directly on top of PlayerBlack, to make it a child of Player black. Vice Versa for BGBlack and PlayerWhite. After the backgrounds are child objects of the player, whenever the player moves, so does the background. Just make sure when you hover over the background objects, that their transform position is now 0,0,0, since it's measured relative to the parent's position (in their case, the player objects).
Another thing that's useful when making levels is to do what Will did and Make empty objects called Left-Side Objects and Right-Side Objects. Everything on the left side (walls, spawners, etc) are child objects of Left-Side Objects, and everything on the right are child objects of Right-Side Objects.
I made one change that should help when placing enemy spawners. I gave them sprites that are circles, and depending on the maxRange set in the object, it'll make the circle around the size of it's actual range (not exact though). It's disabled by default, but you can press Z and it'll show it, like it does with the graph nodes. Basically, the scale of the Object gets set to about myMaxRangeToSpawn+3, and that shows pretty well the range of that spawner. After we're all done making levels, we'll just remove all of that. Just in case you would rather have another way to show the spawn range, I added a function in EnemySpawnController called DrawRange that draws 8 lines corresponding to the range outward from the center.
In terms of sound, I added 3 more songs and a few new noises. I don't think we'll need more music or sound atm. I also made it possible for music to be set up in such a way where there is no intro, and the main loop loops into itself perfectly fine (which you can see in the case of HighlandLoop.ogg).
I added in a placeholder animation thing to the enemies, where after they get frozen, they flash a darker shade of blue about 3 times before turning red again. This is temporary, but if no one really feels like changing it, we can keep it. I also put in place the ability to reset the enemies on screen, but I haven't enabled it (it's commented out).
Random other things:
I fixed a bug with Will's EnemySticky where it would keep moving even when frozen.
I've been using 15/15/15 for the BGBlack's color RGB values, and I think I like it more than 13/13/13. Also, the ClickPositionBlack's color I'm using is 72/72/72 while ClickPositionWhite's color is 96/96/96.

4/6 - Fristian
A small bugfix. It used to be possible to freeze enemies you couldn't see if you clicked on the correct position they were at relative to the other camera. For instance if an enemy was coming at playerWhite from the left side offscreen (and thus, basically under the left half of the game), and you luckily left clicked that spot it was at, it would freeze that enemy. This has been fixed now. You can only freeze enemies if they are in view of the camera when you click on their position.
Also guys, try changing the FOV on CameraWhite and CameraBlack to 115 instead of 110. I think it makes a pretty big difference, and I like it a little more.

4/10 - Fristian
Small things.
I did a really small change in GenerateGraph.cs and it made a huge difference (like, a graph that would take 6 seconds to load now takes less than a second). The problem was that I was making a redundant check in Lookup(). in the if statement, I had an extra: && nodes.ContainsValue(test). But see, the thing is that I already have another dictionary that is nodes, but reversed called sedon, so I don't need to check for values in nodes, I can just check for keys in sedon, which I do two lines later with TryGetValue. So a friendly reminder when using hashtables/dictionaries in C#. ContainsValue is slow! If you can avoid using it, do so. Use TryGetValue as often as you can.
Another thing, I made collisions a bit different. It works similar to how it did before, but the player now should never phase through the wall again. In order for it to work, you'll need to make both player's collider2D not triggers (uncheck isTrigger) and make the rigidbodies not kinematic (uncheck isKinematic). Then it'll be fine. Let me know if you still have any problems (like the camera moving without the player or something.

4/12 - Fristian
I'm adding in a new level here. It's actually difficult, so it's most likely not going to be one of the first levels in the game.
A few things though:
Before pushing to Github, I assume it's best if we have the latest commit downloaded beforehand. What happened on 4/10 was that I pushed mine, but Josh didn't download my commit before he pushed his. So github merged mine and his commits together (there were no conflicts thankfully) and pushed it again as an all new commit, that "Merge branch 'master' of https:/blahblah" thing. So to avoid that in the future, download the latest commit first, then push your own.
When creating a new level, instead of just creating it in your own scene, I suggest copying one of my level scenes, pasting it as a new, and just removing/replacing all the walls and redefining the graph. That's cuz I tend to keep up the things that I change in those scenes, like the FOV change to 115, the player's collider/rigidbodies, the click position's color change to 72/72/72 and 96/96/96, and any tags/layers/audiosources that come with stuff like that. To avoid wondering why something's not working and realizing it's because your players weren't tagged as PlayerBlack/PlayerWhite or were missing an audiosource, or something silly, just use copies of my scenes.
I asked Josh to change the goal prefab to the 'Enemy' layer to prevent enemies from not having vision when within the goal's collider, but that turned out to not be a very good solution, so I fixed it by changing a few lines in the EnemyController script and changing the layer to 'Ignore Raycast'. From now on, if we want objects to be in the level that aren't supposed to be obstacles the enemies can't see you behind (like a goal object, or a removable barrier object), give those objects the 'Ignore Raycast' layer.
I also removed the rigidbody on EnemyMissile, something I forgot to do when we added ridigbodies to the walls.

4/13 - Dylan
Added in a script to introduce idling to the game. The basic premise of the script right now is that it is attached to the main camera and it controls both players idling at the same time. All that needs to be added to a scene to have idling is an extra object on each player called IdleWhite and IdleBlack. The best way to do this is to -
1. copy and paste the background layer
2. change the name to IdleWhite or IdleBlack depending on the player
3. change the sorting layer of the new object to “Player”
4. edit the z-value of the layer to -5
As it is, the idling mechanic does not increase spawn rates yet
For a sample, it is implemented on Level0

4/14 - Fristian
So I took what Dylan did and tried to add enemy functionality with it, but I'll admit my code ended up pretty messy. Sorry bout that.
Important thing I found out: The camera itself has a 'background' field which lets you change the color of that blue background to something else. So since we have that, we don't even need the BGWhite, BGBlack, and Divider objects anymore. Oops. I went ahead and changed that, but it also gave me an idea on what to do with the background objects in the idleController, so I went in and changed a bunch of things. Sorry again.
When I tried to add spawning and other stuff, I realized that it was actually kinda hard, so I tried to make it easier on myself by attaching the IdleController script onto CameraBlack and CameraWhite, while having each one keep track of their own idle. Basically it works like this now:
ClickToMove knows when to send IdleController the signal to start the idling count. It sends this signal if the player hasn't made a valid click, and if the player isn't moving. MoveTo let's ClickToMove know when the player is actually moving. It sends this signal using idler.IsIdling(true), while it tells it it's not idling by using idler.IsIdling(false). Once IdleController gets the signal that the player is idle, it starts incrementing the idleCount. I did it like this to allow for people to freeze enemies and not have that count against their idle time, since like Dylan told me, it still focus's the player's attention on that side, and shouldn't count against them. It works similarly to how it was before afterward, by checking if the idle is past a certain threshold and if so, fogging up the screen (making the background's alpha increase).
So anyway, the BGWhite and BGBlack objects need to be swapped now, so that the left side fades to black and the right side fades to white. With this it's actually a little more intuitive, in that PlayerBlack is a parent to BGBlack, and PlayerWhite is a parent to BGWhite. Also, instead of changing the z to -5, we can actually change the sprite layer to player and make sure the OrderInLayer section is 1, which places the BGObject's sprite in front of the player like we want. I've implemented this in Level0 and LevelRotator.
On the enemy spawning issue, I'm not done with it yet I don't think. I'm getting a lot of weird errors when I run it sometimes, and other times I don't get them (usually has to do with the enemies having certain things be null after being spawned or something). The way idling should work now is that after a time, when your screen fogs, the only thing that happens is that the enemies on screen get faster. Once your screen is fully obscured is when it spawns more enemies on nodes near the border of your screen. I'll keep testing it to see if I can fix some of those errors I get sometimes, but for now it works most times.
Also, on further inspection, I realized that deadlyMouseButton wasn't actually necessary, so I removed it.
